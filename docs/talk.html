<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Introducción a SOLID</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="style/ude.css" id="theme"><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css"><link href="css/github.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js/css/print/pdf.css" : "reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><script type="text/javascript">
    window.addEventListener("load", function() {

        revealDiv = document.querySelector("body div.reveal")
        footer = document.getElementById("schauderhaft-footer");
        revealDiv.appendChild(footer);

    } );
</script>
<div id="schauderhaft-footer" class="footer">
    <span class="element">ACCSA</span>
    <span class="element"></span>
    <span class="element">Intro SOLID</span>
</div>
<section id="_introducción_a_solid"><h2>Introducción a SOLID</h2></section>
<section id="_principios_solid"><h2>Principios SOLID</h2><div class="ulist"><ul><li><p>Single responsibility <span class="icon"><i class="fa fa-cube"></i></span></p></li><li><p>Open closed <span class="icon"><i class="fa fa-unlock"></i></span>/<span class="icon"><i class="fa fa-lock"></i></span></p></li><li><p>Liskov substitution <span class="icon"><i class="fa fa-users"></i></span></p></li><li><p>Interface segregation <span class="icon"><i class="fa fa-cut"></i></span></p></li><li><p>Dependency inversion <span class="icon"><i class="fa fa-cubes"></i></span></p></li></ul></div></section>
<section id="_principio_de_responsabilidad_única"><h2>Principio de Responsabilidad Única <span class="icon"><i class="fa fa-cube"></i></span></h2><div class="paragraph"><p><strong>Un objeto debe realizar una única cosa</strong>.</p></div>
<div class="paragraph"><p><strong>Un objeto debe tener una sola razón para cambiar.</strong></p></div>
<aside class="notes"><div class="paragraph"><p>Es muy habitual, si no prestamos atención a esto, que acabemos
teniendo clases que tienen varias responsabilidades lógicas a la vez.</p></div></aside></section>
<section id="_cómo_detectar_si_estamos_violando_el_principio_de_responsabilidad_única"><h2>¿Cómo detectar si estamos violando el Principio de Responsabilidad Única?</h2></section>
<section><div class="ulist"><ul><li><p>En una misma clase están involucradas dos capas de la arquitectura</p></li><li><p>El número de métodos públicos</p></li><li><p>Los métodos que usan cada uno de los campos de esa clase</p></li><li><p>Por el número de imports</p></li></ul></div></section>
<section><div class="ulist"><ul><li><p>Nos cuesta testear la clase</p></li><li><p>Cada vez que escribes una nueva funcionalidad, esa clase se ve afectada</p></li><li><p>Por el número de líneas</p></li></ul></div></section>
<section id="_ejemplo"><h2>Ejemplo</h2><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class Vehicle {
  private val wheelCount = 4
  private val maxSpeed = 200
  override fun toString():String {
    return "wheelCount=$wheelCount, maxSpeed=$maxSpeed"
  }
  fun print() {
    println(toString())
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Esta es una clase sencilla con datos y lógica de negocio.</p></div></aside></section>
<section id="_qué_problema_tiene_esta_clase"><h2>¿Qué problema tiene esta clase?</h2></section>
<section><div class="ulist"><ul><li><p>Mezcla de lógica con presentación</p></li></ul></div></section>
<section id="_cómo_arreglarlo"><h2>¿Cómo arreglarlo?</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class VehiclePrinter {
  fun print(vehicle:Vehicle) {
    println(vehicle)
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este caso implementando un printer dedicado.</p></div></aside></section>
<section id="_principio_openclosed"><h2>Principio Open/Closed <span class="icon"><i class="fa fa-unlock"></i></span>/<span class="icon"><i class="fa fa-lock"></i></span></h2><div class="paragraph"><p><strong>Una entidad de software debería estar abierta a extensión pero cerrada a modificación</strong>.</p></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_openclosed"><h2>¿Cómo detectar que estamos violando el principio Open/Closed?</h2></section>
<section><div class="ulist"><ul><li><p>Clases que modificamos más seguido (hits of code)</p></li></ul></div></section>
<section id="_ejemplo_2"><h2>Ejemplo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class Vehicle {
  //…
  val type:VehicleType
  //…
}
enum class VehicleType {
  CAR,
  MOTORBIKE;
}
fun draw(vehicle:Vehicle) {
    when (vehicle.type) {
      CAR -&gt; drawCar(vehicle)
      MOTORBIKE -&gt; drawMotorbike(vehicle)
    }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Siguiendo con el ejemplo del vehículo anterior, ahora con funcionalidad de dibujar <code>draw</code>. Al principio es sencilla la implementación y puede ser suficiente para la aplicación, pero se presenta que cada vez que se quiera dibujar un nuevo vehículo se debe actualizar el contenido del método, el enum y la lógica en la propia que clase que nos interesaría dibujar.</p></div></aside></section>
<section id="_qué_podemos_hacer_para_evitar_tener_que_estar_modificando_el_método_draw"><h2>¿Qué podemos hacer para evitar tener que estar modificando el método <code>draw</code>?</h2></section>
<section id="_polimorfismo"><h2>Polimorfismo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">abstract class Vehicle {
  //…
  abstract fun draw()
}
class Car:Vehicle() {
  override fun draw() {
    // Draw the car
  }
}
class Motorbike:Vehicle() {
  override fun draw() {
    // Draw the motorbike
  }
}</code></pre></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">fun draw(vehicle:Vehicle) {
  vehicle.draw()
}
class Truck:Vehicle() {
  override fun draw() {
    // Draw the truck
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Al utilizar polimorfismo en este caso cada objeto que deseemos dibujar lo único que necesita es implementar la interfaz. Adicionalmente se simplifica el método draw original, pues en runtime invocará la implementación correspondiente, por lo que ya no necesitamos el enum para este caso.</p></div></aside></section>
<section id="_cuándo_debemos_cumplir_con_este_principio"><h2>¿Cuándo debemos cumplir con este principio?</h2><div class="ulist"><ul><li><p>Depende, debe aplicarse cuando es necesario. La complejidad no siempre compensa.</p></li><li><p>Un caso práctico es cuando hay partes de nuestro código que cambien mucho.</p></li></ul></div></section>
<section id="_principio_de_sustitución_de_liskov"><h2>Principio de Sustitución de Liskov <span class="icon"><i class="fa fa-users"></i></span></h2><div class="paragraph"><p><strong>Si en alguna parte de nuestro código estamos usando una clase, y esta clase es extendida, tenemos que poder utilizar cualquiera de las clases hijas y que el programa siga siendo válido.</strong></p></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_de_sustitución_de_liskov"><h2>¿Cómo detectar que estamos violando el principio de sustitución de Liskov?</h2><div class="ulist"><ul><li><p>Si un método sobrescrito no hace nada o lanza una excepción.</p></li></ul></div></section>
<section id="_ejemplo_3"><h2>Ejemplo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">open class Rectangle {
  open var width:Int = 0
  open var height:Int = 0
  open fun calculateArea():Int {
    return width * height
  }
}
@Test
fun givenRectangle_whenCalculateArea_thenCorrectResult() {
  val r = Rectangle()
  r.width = 5
  r.height = 4

  val result = r.calculateArea()

  assertEquals(20, result)
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este caso tenemos un rectángulo común y un test para probar el cálculo del área.</p></div></aside></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class Square:Rectangle() {
  override var width:Int
  get() {
    return super.width
  }
  set(width) {
    super.width = width
    super.height = width
  }
  override var height:Int
  get() {
    return super.height
  }
  set(height) {
    super.height = height
    super.width = height
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>La pudiéramos extender para soportar por ejemplo un cuadrado.</p></div></aside></section>
<section id="_qué_pasará_si_en_el_test_cambiamos_el_rectángulo_por_un_cuadrado"><h2>¿Qué pasará si en el test cambiamos el rectángulo por un cuadrado?</h2></section>
<section id="_1620"><h2>16!=20</h2><aside class="notes"><div class="paragraph"><p>El test falla porque cada vez que cambiamos un lado afectamos el otro.</p></div></aside></section>
<section id="_qué_podemos_hacer"><h2>¿Qué podemos hacer?</h2><div class="ulist"><ul><li><p>Usar interfaces, normalmente pequeñas.</p></li><li><p>Inmutabilidad (Una vez que se ha creado un objeto, el estado del mismo no puede volver a modificarse)</p></li></ul></div></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface IRectangle {
  fun calculateArea():Int
}
class Rectangle:IRectangle//…
class Square:IRectangle//…</code></pre></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">open class Rectangle(private val width:Int, private val height:Int)
class Square(private val side:Int):Rectangle(side, side)</code></pre></section>
<section id="_principio_de_segregación_de_interfaces"><h2>Principio de segregación de interfaces <span class="icon"><i class="fa fa-cut"></i></span></h2><div class="paragraph"><p><strong>Ninguna clase debería depender de métodos que no usa.</strong></p></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_de_segregación_de_interfaces"><h2>¿Cómo detectar que estamos violando el Principio de segregación de interfaces?</h2><div class="ulist"><ul><li><p>Al implementar una interfaz ves que uno o varios de los métodos no tienen sentido y te hace falta dejarlos vacíos o
lanzar excepciones</p></li></ul></div></section>
<section id="_ejemplo_4"><h2>Ejemplo</h2><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface Product {
  fun name():String
  fun stock():Int
  fun numberOfDisks():Int
  fun releaseDate():Date
}
class CD:Product//…</code></pre>
<aside class="notes"><div class="paragraph"><p>Imaginemos que una tienda que vende CD musicales el sistema de datos esta modelado con esa interfaz.</p></div></aside></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface Product {
  //…
  fun recommendedAge():Int
}
class CD:Product {
  //…
  override fun recommendedAge():Int {
    throw UnsupportedOperationException()
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Pero si ahora deseamos vender DVD y queremos limitar la edad por ejemplo.</p></div></aside></section>
<section id="_qué_podemos_hacer_2"><h2>¿Qué podemos hacer?</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface AgeAware {
  fun recommendedAge():Int
}
class CD:Product//…
class DVD:Product, AgeAware {
  fun checkUserCanBuy(user:User, ageAware:AgeAware):Boolean {
    return user.age &gt;= ageAware.recommendedAge()
  }
  //…
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este caso ahora tenemos una interfaz más chica <code>AgeAware</code>, con responsabilidades acotadas y no afecta a la clase <code>CD</code>.</p></div></aside></section>
<section id="_qué_hacer_con_código_antiguo"><h2>¿Qué hacer con código antiguo?</h2><div class="ulist"><ul><li><p>Usar el patrón adapter</p></li></ul></div></section>
<section id="_principio_de_inversión_de_dependencias"><h2>Principio de inversión de dependencias <span class="icon"><i class="fa fa-cubes"></i></span></h2><div class="ulist"><ul><li><p><strong>Las clases de alto nivel no deberían depender de las clases de bajo nivel</strong>. Ambas deberían depender de las abstracciones.</p></li><li><p><strong>Las abstracciones no deberían depender de los detalles</strong>. Los detalles deberían depender de las abstracciones.</p></li></ul></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_de_inversión_de_dependencias"><h2>¿Cómo detectar que estamos violando el Principio de inversión de dependencias?</h2><div class="ulist"><ul><li><p>Cualquier instanciación de clases complejas o módulos es una
violación de este principio.</p></li></ul></div></section>
<section id="_ejemplo_5"><h2>Ejemplo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class ShoppingBasket {
  fun buy(shopping:Shopping) {
    val db = SqlDatabase()
    db.save(shopping)
    val creditCard = CreditCard()
    creditCard.pay(shopping)
  }
}
class SqlDatabase {
  fun save(shopping:Shopping) {
    // Saves data in SQL database
  }
}
class CreditCard {
  fun pay(shopping:Shopping) {
    // Performs payment using a credit card
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este ejemplo tenemos la clase <code>ShoppingBasket</code> que persiste y envía el pago por tarjeta de crédito. El problema que tiene es que primero depende de clases concretas en vez de abstracciones y segundo estás dependencias son creadas dentro de la propia clase.</p></div></aside></section>
<section id="_cómo_lo_solucionamos"><h2>¿Cómo lo solucionamos?</h2><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface Persistence {
  fun save(shopping:Shopping)
}
class SqlDatabase:Persistence {
  override fun save(shopping:Shopping) {
    // Saves data in SQL database
  }
}
interface PaymentMethod {
  fun pay(shopping:Shopping)
}
class CreditCard:PaymentMethod {
  override fun pay(shopping:Shopping) {
    // Performs payment using a credit card
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Una manera de arreglarlo es crear interfaces dedicadas para las dependencias.</p></div></aside></section>
<section id="_ahora_inyectamos_las_dependencias"><h2>Ahora inyectamos las dependencias</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class ShoppingBasket(private val persistence:Persistence, private val paymentMethod:PaymentMethod) {
  fun buy(shopping:Shopping) {
    persistence.save(shopping)
    paymentMethod.pay(shopping)
  }
}
class Server:Persistence {
  override fun save(shopping:Shopping) {
    // Saves data in a server
  }
}
class Paypal:PaymentMethod {
  override fun pay(shopping:Shopping) {
    // Performs payment using Paypal account
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Y ahora les pasamos las dependencias al constructor de la clase, esto nos da la flexibilidad de cambiar la implementación sin necesidad de actualizar la clase. Otra ventaja es que al tener las dependencias en el constructor se nos da una vista previa de las responsabilidades que esta clase maneja, pudiendo detectar rápidamente en caso que empiece a crecer la violación del principio de responsabilidad única.</p></div></aside></section>
<section id="_conclusiones_solid"><h2>Conclusiones SOLID</h2><div class="ulist"><ul><li><p>SRP implica que sólo debería haber un motivo por el que modificar una clase.</p></li><li><p>Tener código cerrado a modificación y abierto a extensión nos da la máxima flexibilidad con el mínimo impacto.</p></li><li><p>El principio de Liskov nos ayuda a utilizar la herencia de forma correcta</p></li></ul></div></section>
<section id="_conclusiones_solid_2"><h2>Conclusiones SOLID</h2><div class="ulist"><ul><li><p>El principio de segregación de interfaces nos ayuda a no obligar a ninguna clase a implementar métodos que no utiliza.</p></li></ul></div></section>
<section><div class="ulist"><ul><li><p>Fuentes:</p><div class="ulist"><ul><li><p><a href="https://devexperto.com/principio-responsabilidad-unica/">Pricipios SOLID - DevExperto</a></p></li></ul></div></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Para generar pdf incluir al final de la presentación lo siguiente: ?showNotes=separate-page&amp;print-pdf</p></div></aside></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: false,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: 'true',
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'linear',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>